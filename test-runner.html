<link rel="import" href="../../bower_components/polymer/polymer.html">

<dom-module id="test-runner">
    <template>
        <style>
            /*TODO is host the correct selector here? */
            :host {
                --box-shadow: 0px 0px 1px black;
            }

            .gridWrapper {
                display: grid;
                grid-template-columns: 1fr 1fr 1fr 10fr 10fr;
                grid-gap: 10px;
                grid-auto-rows: minmax(50px, auto);
            }

            .componentCheckboxContainer {
                grid-column: 1;
                box-shadow: var(--box-shadow);
            }

            .componentNumTestsInputContainer {
                grid-column: 2;
                box-shadow: var(--box-shadow);
            }

            .componentLabelContainer {
                grid-column: 3 / 5;
                box-shadow: var(--box-shadow);
                padding: 10px;
                cursor: pointer;
            }

            .testCheckboxContainer {
                grid-column: 2;
                box-shadow: var(--box-shadow);
            }

            .testNumTestsInputContainer {
                grid-column: 3;
                box-shadow: var(--box-shadow);
            }

            .testLabelContainer {
                grid-column: 4 / 5;
                box-shadow: var(--box-shadow);
                padding: 10px;
            }

            .numTestsInputContainer {
                width: 3vw;
            }
        </style>

        <button on-click="runTests">Run tests</button>

        <br>
        <br>

        <div class="gridWrapper">
            <template is="dom-repeat" items="[[testComponents]]">
                <div class="componentCheckboxContainer">
                    <input id="[[getShouldRunInputId(item.localName)]]" type="checkbox" on-change="componentShouldRunInputOnChanged" checked$="[[item.shouldRunValue]]">
                </div>
                <div class="componentNumTestsInputContainer">
                    <input id="[[getNumTestsInputId(item.localName)]]" type="number" on-input="componentNumTestsInputOnInput" value="[[item.numTestsValue]]" class="numTestsInputContainer">
                </div>
                <div class="componentLabelContainer" on-click="showChildrenClick">
                    <[[item.localName]]>
                </div>
                <template is="dom-if" if="[[showChildren]]">
                    <template is="dom-repeat" items="[[item.tests]]">
                        <div class="testCheckboxContainer">
                            <input id="[[getShouldRunInputId(item.description)]]" type="checkbox" on-change="testShouldRunInputOnChanged" checked$="[[item.shouldRunValue]]">
                        </div>
                        <div class="testNumTestsInputContainer">
                            <input id="[[getNumTestsInputId(item.description)]]" type="number" on-input="testNumTestsInputOnInput" value="[[item.numTestsValue]]" class="numTestsInputContainer">
                        </div>
                        <div class="testLabelContainer">
                            [[item.description]]
                        </div>
                    </template>
                </template>
            </template>
        </div>
    </template>

    <script>
        class TestRunner extends Polymer.Element {
            static get is() { return 'test-runner'; }
            static get properties() {
                return {
                    autoRun: {
                        type: Boolean
                    }
                };
            }

            getLocalNameFromShouldRunInputId(id) {
                return id.replace('-should-run-input', '');
            }

            getLocalNameFromNumTestsInputId(id) {
                return id.replace('-num-tests-input', '');
            }

            replaceSpaces(string) {
                return string.split(' ').join('-');
            }

            getShouldRunInputId(string) {
                return `${this.replaceSpaces(string)}-should-run-input`;
            }

            getNumTestsInputId(string) {
                return `${this.replaceSpaces(string)}-num-tests-input`;
            }

            showChildrenClick() {
                this.showChildren = !this.showChildren;
            }

            componentShouldRunInputOnChanged(event) {
                window.localStorage.setItem(event.target.id, event.target.checked);
                const localName = this.getLocalNameFromShouldRunInputId(event.target.id);
                const testComponent = this.testComponents.find((testComponent) => {
                    return testComponent.localName === localName;
                });
                testComponent.tests.forEach((test) => {
                    const shouldRunInput = this.shadowRoot.querySelector(`#${this.getShouldRunInputId(test.description)}`);
                    shouldRunInput.checked = event.target.checked;
                    shouldRunInput.dispatchEvent(new Event('change'));
                });
            }

            testShouldRunInputOnChanged(event) {
                window.localStorage.setItem(event.target.id, event.target.checked);
            }

            componentNumTestsInputOnInput(event) {
                window.localStorage.setItem(event.target.id, event.target.value);
                const localName = this.getLocalNameFromNumTestsInputId(event.target.id);
                const testComponent = this.testComponents.find((testComponent) => {
                    return testComponent.localName === localName;
                });
                testComponent.tests.forEach((test) => {
                    const numTestsInput = this.shadowRoot.querySelector(`#${this.getNumTestsInputId(test.description)}`);
                    numTestsInput.value = event.target.value;
                    numTestsInput.dispatchEvent(new Event('input'));
                });
            }

            testNumTestsInputOnInput(event) {
                window.localStorage.setItem(event.target.id, event.target.value);
            }

            //TODO figure out the idiomatic way to access the "light DOM" children in Polymer 2 or just plain custom elements once we upgrade this to the V1 specs
            connectedCallback() {
                super.connectedCallback();

                setTimeout(() => { //TODO once we move to Polymer 2 and the custom elements v1 specs, figure out this timing issue. The problem is that in a Polymer 1 component the prepareTests method is not always defined immediately
                    this.testComponents = Array.from(this.children).map((testComponent) => {
                        testComponent.shouldRunValue = window.localStorage.getItem(this.getShouldRunInputId(testComponent.localName)) === 'true' ? true : false;
                        testComponent.numTestsValue = window.localStorage.getItem(this.getNumTestsInputId(testComponent.localName));
                        testComponent.prepareTests((description, test) => {
                            testComponent.tests = [...(testComponent.tests || []), {
                                localName: testComponent.localName,
                                description,
                                test,
                                shouldRunValue: window.localStorage.getItem(this.getShouldRunInputId(description)) === 'true' ? true : false,
                                numTestsValue: window.localStorage.getItem(this.getNumTestsInputId(description))
                            }];
                        });
                        return testComponent;
                    });
                    setTimeout(() => {
                        this.showChildrenClick();
                    }, 1000);
                }, 1000);
            }

            async runTests() {
                delete require.cache[require.resolve('tape')]; //this is necessary so that tape will run tests fresh each time. Apparently it keeps some state around that does not let the tests run multiple times
                const tape = require('tape');
                const {ipcRenderer} = require('electron');

                tape.onFinish((event) => {
                    if (this.autoRun) {
                        ipcRenderer.sendSync('kill-all-processes-successfully');
                    }
                });

                // Using for loops to allow easy async for each
                for (let i=0; i < this.testComponents.length; i++) {
                    const testComponent = this.testComponents[i];
                    for (let j=0; j < testComponent.tests.length; j++) {
                        const test = testComponent.tests[j];
                        // autoRun will run all tests
                        const shouldRun = this.autoRun ? true : this.shadowRoot.querySelector(`#${this.getShouldRunInputId(test.description)}`).checked;
                        if (shouldRun) {
                            //TODO if you are auto running the tests, just do 100 for now. We will allow the number of tests to be configured on an auto run later
                            const numTests = this.autoRun ? '100' : this.shadowRoot.querySelector(`#${this.getNumTestsInputId(test.description)}`).value;
                            await test.test(tape, test.description, numTests);
                        }
                    }
                }
            }
        }

        window.customElements.define(TestRunner.is, TestRunner);
    </script>
</dom-module>
